# generated by datamodel-codegen:
#   filename:  dsp.yaml
#   timestamp: 2021-01-19T11:21:52+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field, conint


class OrderFlight(BaseModel):
    flightId: Optional[str] = Field(
        None, description='The flight identifier. Immutable field.'
    )
    startDateTime: str = Field(
        ...,
        description='The flight start date in ISO format (YYYY-MM-DD hh:mm:ss z). Timezone is UTC. For example, 2020-10-21 03:59:00 UTC.',
    )
    endDateTime: str = Field(
        ...,
        description='The flight start date in ISO format (YYYY-MM-DD hh:mm:ss z). Timezone is UTC. For example, 2020-10-21 03:59:00 UTC.',
    )
    amount: float = Field(..., description='The total flight budget amount.')
    spentAmount: Optional[float] = Field(
        None, description='The spent flight budget amount.'
    )
    remainingAmount: Optional[float] = Field(
        None, description='The remaining flight budget amount.'
    )


class AgencyFee(BaseModel):
    feePercentage: Optional[float] = Field(
        None, description='Fee expressed as a percentage of the total budget.'
    )


class ProductLocation(Enum):
    SOLD_ON_AMAZON = 'SOLD_ON_AMAZON'
    NOT_SOLD_ON_AMAZON = 'NOT_SOLD_ON_AMAZON'


class Goal(Enum):
    AWARENESS = 'AWARENESS'
    ENGAGEMENT_WITH_MY_AD = 'ENGAGEMENT_WITH_MY_AD'
    CONSIDERATIONS_ON_AMAZON = 'CONSIDERATIONS_ON_AMAZON'
    CONVERSIONS_OFF_AMAZON = 'CONVERSIONS_OFF_AMAZON'
    PURCHASES_ON_AMAZON = 'PURCHASES_ON_AMAZON'
    MOBILE_APP_INSTALLS = 'MOBILE_APP_INSTALLS'


class GoalKpi(Enum):
    CLICK_THROUGH_RATE = 'CLICK_THROUGH_RATE'
    COST_PER_ACQUISITION = 'COST_PER_ACQUISITION'
    COST_PER_CLICK = 'COST_PER_CLICK'
    COST_PER_DETAIL_PAGE_VIEW = 'COST_PER_DETAIL_PAGE_VIEW'
    COST_PER_DOWNLOAD = 'COST_PER_DOWNLOAD'
    COST_PER_VIDEO_COMPLETION = 'COST_PER_VIDEO_COMPLETION'
    DETAIL_PAGE_VIEW_RATE = 'DETAIL_PAGE_VIEW_RATE'
    NONE = 'NONE'
    OTHER = 'OTHER'
    REACH = 'REACH'
    RETURN_ON_AD_SPEND = 'RETURN_ON_AD_SPEND'
    TOTAL_RETURN_AD_SPEND = 'TOTAL_RETURN_ON_AD_SPEND'
    VIDEO_COMPLETION_RATE = 'VIDEO_COMPLETION_RATE'


class AutoOptimization(Enum):
    BUDGET = 'BUDGET'
    BID = 'BID'


class BiddingStrategy(Enum):
    SPEND_BUDGET_IN_FULL = 'SPEND_BUDGET_IN_FULL'
    MAXIMIZE_PERFORMANCE = 'MAXIMIZE_PERFORMANCE'


class OrderOptimization(BaseModel):
    productLocation: ProductLocation = Field(
        ...,
        description='The product location indicates whether the product is endemic or non-endemic.',
    )
    goal: Goal = Field(..., description='The budget optimization goal type.')
    goalKpi: GoalKpi = Field(..., description='KPI for the selected goal.')
    autoOptimizations: Optional[List[AutoOptimization]] = Field(
        None, description='The list of optimizations supported.'
    )
    biddingStrategy: Optional[BiddingStrategy] = Field(
        None,
        description='It specifies how Amazon Advertising determines bids on your behalf for each opportunity to serve an impression. It is immutable once the order has started delivering.\n',
    )


class OrderDeliveryStatus(Enum):
    DELIVERING = 'DELIVERING'
    ENDED = 'ENDED'
    OUT_OF_BUDGET = 'OUT_OF_BUDGET'
    LINEITEMS_NOT_RUNNING = 'LINEITEMS_NOT_RUNNING'
    INACTIVE = 'INACTIVE'
    READY_TO_DELIVER = 'READY_TO_DELIVER'


class LineItemType(Enum):
    STANDARD_DISPLAY = 'STANDARD_DISPLAY'
    AMAZON_MOBILE_DISPLAY = 'AMAZON_MOBILE_DISPLAY'
    AAP_MOBILE_APP = 'AAP_MOBILE_APP'
    OTT_GUARANTEED = 'OTT_GUARANTEED'
    VIDEO = 'VIDEO'
    UNDEFINED = 'undefined'  # Hack to resolve bug from client


class DeviceTypeTargeting(Enum):
    DESKTOP_AND_MOBILE = 'DESKTOP_AND_MOBILE'
    MOBILE = 'MOBILE'
    DESKTOP = 'DESKTOP'


class SiteLanguageTargeting(Enum):
    EN = 'EN'
    ES = 'ES'


class DeviceTypeTargetingEnum(Enum):
    IPHONE = 'IPHONE'
    IPAD = 'IPAD'
    ANDROID = 'ANDROID'
    KINDLE_FIRE = 'KINDLE_FIRE'
    KINDLE_FIRE_HD = 'KINDLE_FIRE_HD'


class DeviceOrientationTargeting(Enum):
    ANY = 'ANY'
    PORTRAIT = 'PORTRAIT'
    LANDSCAPE = 'LANDSCAPE'


class UserLocationTargeting(Enum):
    US = 'US'
    EVERYWHERE = 'EVERYWHERE'
    NON_US = 'NON_US'


class LocationTargetingBy(Enum):
    IPADDRESS = 'IPADDRESS'
    IPADDRESS_POSTALCODE = 'IPADDRESS_POSTALCODE'


class IntraOperator(Enum):
    AND = 'AND'
    OR = 'OR'


class InterOperator(Enum):
    ANY = 'ANY'
    ALL = 'ALL'


class ViewabilityTier(Enum):
    ALLOW_ALL = 'ALLOW_ALL'
    VIEWABILITY_TIER_GT70 = 'VIEWABILITY_TIER_GT70'
    VIEWABILITY_TIER_GT60 = 'VIEWABILITY_TIER_GT60'
    VIEWABILITY_TIER_GT50 = 'VIEWABILITY_TIER_GT50'
    VIEWABILITY_TIER_GT40 = 'VIEWABILITY_TIER_GT40'
    VIEWABILITY_TIER_LT40 = 'VIEWABILITY_TIER_LT40'


class DoubleVerifyAuthenticBrandSafety(BaseModel):
    doubleVerifySegmentId: Optional[str] = Field(
        None, description='The segment identifier.'
    )


class HighSeverityContentEnum(Enum):
    ADULT_CONTENT = 'ADULT_CONTENT'
    DRUGS_SUBSTANCES = 'DRUGS_SUBSTANCES'
    EXTREME_GRAPHICS_VIOLENCE_WEAPONS = 'EXTREME_GRAPHICS_VIOLENCE_WEAPONS'
    HATE_SPEECH_PROFANITY = 'HATE_SPEECH_PROFANITY'
    ILLEGAL_ACTIVITIES = 'ILLEGAL_ACTIVITIES'
    INCENTIVIZED_MALWARE_CLUTTER = 'INCENTIVIZED_MALWARE_CLUTTER'
    PIRACY_COPYRIGHT_INFRINGEMENT = 'PIRACY_COPYRIGHT_INFRINGEMENT'


class MediumSeverityContentEnum(Enum):
    AD_SERVER = 'AD_SERVER'
    ADULT_CONTENT = 'ADULT_CONTENT'
    CULTS_SURVIVALISM = 'CULTS_SURVIVALISM'
    CELEBRITY_GOSSIP = 'CELEBRITY_GOSSIP'
    GAMBLING = 'GAMBLING'
    DISASTER_AVIATION = 'DISASTER_AVIATION'
    DISASTER_MAN_MADE = 'DISASTER_MAN_MADE'
    DISASTER_NATURAL = 'DISASTER_NATURAL'
    DISASTER_TERRORISTS_EVENTS = 'DISASTER_TERRORISTS_EVENTS'
    DISASTER_VEHICLE = 'DISASTER_VEHICLE'
    DRUGS_ALCOHOL = 'DRUGS_ALCOHOL'
    DRUGS_SMOKING = 'DRUGS_SMOKING'
    INFLAMMATORY_POLITICS_NEWS = 'INFLAMMATORY_POLITICS_NEWS'
    NEGATIVE_NEWS_FINANCIAL = 'NEGATIVE_NEWS_FINANCIAL'
    NEGATIVE_NEWS_PHARMACEUTICAL = 'NEGATIVE_NEWS_PHARMACEUTICAL'
    NON_STANDARD_CONTENT_NON_ENGLISH = 'NON_STANDARD_CONTENT_NON_ENGLISH'
    NON_STANDARD_CONTENT_PARKING_PAGE = 'NON_STANDARD_CONTENT_PARKING_PAGE'
    OCCULT = 'OCCULT'
    SEX_EDUCATION = 'SEX_EDUCATION'
    UNMODERATED_UGC_FORUMS_IMAGES_VIDEO = 'UNMODERATED_UGC_FORUMS_IMAGES_VIDEO'


class AppAgeRatingEnum(Enum):
    EVERYONE = 'EVERYONE'
    TWEENS = 'TWEENS'
    TEEN = 'TEEN'
    MATURE = 'MATURE'
    ADULTS_ONLY = 'ADULTS_ONLY'
    UNKNOWN = 'UNKNOWN'


class AppStarRating(Enum):
    ALLOW_ALL = 'ALLOW_ALL'
    APP_STAR_RATING_LT_15 = 'APP_STAR_RATING_LT_15'
    APP_STAR_RATING_LT_20 = 'APP_STAR_RATING_LT_20'
    APP_STAR_RATING_LT_25 = 'APP_STAR_RATING_LT_25'
    APP_STAR_RATING_LT_30 = 'APP_STAR_RATING_LT_30'
    APP_STAR_RATING_LT_35 = 'APP_STAR_RATING_LT_35'
    APP_STAR_RATING_LT_40 = 'APP_STAR_RATING_LT_40'
    APP_STAR_RATING_LT_45 = 'APP_STAR_RATING_LT_45'


class DoubleVerifyBrandSafety(BaseModel):
    highSeverityContent: Optional[List[HighSeverityContentEnum]] = Field(
        None, description='A list of high severity content and corresponding status.'
    )
    mediumSeverityContent: Optional[List[MediumSeverityContentEnum]] = Field(
        None, description='A list of medium severity content and corresponding status.'
    )
    unknownContent: Optional[bool] = Field(
        None, description='Set to `true` to exclude unknown content.'
    )
    appAgeRating: Optional[List[AppAgeRatingEnum]] = Field(
        None, description='A list of app age rating to be used for excluding apps.'
    )
    appStarRating: Optional[AppStarRating] = Field(
        None, description='Exclude by app star rating (app inventory only)'
    )
    excludeAppsWithInsufficientRating: Optional[bool] = Field(
        None,
        description='Set to `true` to exclude unofficial apps or apps with insufficient user ratings (<100 lifetime).',
    )


class ExcludeAppsAndSites(Enum):
    ALLOW_ALL = 'ALLOW_ALL'
    FRAUD_TRAFFIC_LEVEL_GTE_100 = 'FRAUD_TRAFFIC_LEVEL_GTE_100'
    FRAUD_TRAFFIC_LEVEL_GTE_50 = 'FRAUD_TRAFFIC_LEVEL_GTE_50'
    FRAUD_TRAFFIC_LEVEL_GTE_25 = 'FRAUD_TRAFFIC_LEVEL_GTE_25'
    FRAUD_TRAFFIC_LEVEL_GTE_10 = 'FRAUD_TRAFFIC_LEVEL_GTE_10'
    FRAUD_TRAFFIC_LEVEL_GTE_08 = 'FRAUD_TRAFFIC_LEVEL_GTE_08'
    FRAUD_TRAFFIC_LEVEL_GTE_06 = 'FRAUD_TRAFFIC_LEVEL_GTE_06'
    FRAUD_TRAFFIC_LEVEL_GTE_04 = 'FRAUD_TRAFFIC_LEVEL_GTE_04'
    FRAUD_TRAFFIC_LEVEL_GTE_02 = 'FRAUD_TRAFFIC_LEVEL_GTE_02'


class DoubleVerifyFraudInvalidTraffic(BaseModel):
    excludeImpressions: Optional[bool] = Field(
        None,
        description='Set to `true` to exclude impressions delivered to devices identified to be fraudulent or invalid.',
    )
    excludeAppsAndSites: Optional[ExcludeAppsAndSites] = None
    blockAppAndSites: Optional[bool] = Field(
        None,
        description='Set to `true` to block applications and sites with insufficient historical fraud and invalid traffic statistics. This will not be applicable if ALLOW_ALL is chosen.',
    )


class MrcViewabilityTargeting(Enum):
    ALLOW_ALL = 'ALLOW_ALL'
    MRC_VIEWABILITY_GTE_80 = 'MRC_VIEWABILITY_GTE_80'
    MRC_VIEWABILITY_GTE_75 = 'MRC_VIEWABILITY_GTE_75'
    MRC_VIEWABILITY_GTE_70 = 'MRC_VIEWABILITY_GTE_70'
    MRC_VIEWABILITY_GTE_65 = 'MRC_VIEWABILITY_GTE_65'
    MRC_VIEWABILITY_GTE_60 = 'MRC_VIEWABILITY_GTE_60'
    MRC_VIEWABILITY_GTE_55 = 'MRC_VIEWABILITY_GTE_55'
    MRC_VIEWABILITY_GTE_50 = 'MRC_VIEWABILITY_GTE_50'
    MRC_VIEWABILITY_GTE_40 = 'MRC_VIEWABILITY_GTE_40'
    MRC_VIEWABILITY_GTE_30 = 'MRC_VIEWABILITY_GTE_30'


class BrandExposureViewabilityTargeting(Enum):
    ALLOW_ALL = 'ALLOW_ALL'
    BRAND_EXPOSURE_VIEWABILITY_GTE_15_SEC_AVG_DURATION = (
        'BRAND_EXPOSURE_VIEWABILITY_GTE_15_SEC_AVG_DURATION'
    )
    BRAND_EXPOSURE_VIEWABILITY_GTE_10_SEC_AVG_DURATION = (
        'BRAND_EXPOSURE_VIEWABILITY_GTE_10_SEC_AVG_DURATION'
    )
    BRAND_EXPOSURE_VIEWABILITY_GTE_5_SEC_AVG_DURATION = (
        'BRAND_EXPOSURE_VIEWABILITY_GTE_5_SEC_AVG_DURATION'
    )


class DoubleVerifyViewability(BaseModel):
    mrcViewabilityTargeting: Optional[MrcViewabilityTargeting] = Field(
        None, description='The type of MRC viewability targeting.'
    )
    brandExposureViewabilityTargeting: Optional[
        BrandExposureViewabilityTargeting
    ] = Field(None, description='The type of brand exposure viewability targeting.')
    includeUnmeasurableImpressions: Optional[bool] = Field(
        None,
        description="Set to `true` to include impressions where impressions can't be measured.",
    )


class FraudInvalidTraffic(Enum):
    ALLOW_ALL = 'ALLOW_ALL'
    FRAUD_INVALID_TRAFFIC_ESSENTIAL_PROTECTION = (
        'FRAUD_INVALID_TRAFFIC_ESSENTIAL_PROTECTION'
    )
    FRAUD_INVALID_TRAFFIC_MAXIMUM_PROTECTION = (
        'FRAUD_INVALID_TRAFFIC_MAXIMUM_PROTECTION'
    )


class TargetingOption(Enum):
    NO_BRAND_SAFETY = 'NO_BRAND_SAFETY'
    MAXIMUM_PROTECTION = 'MAXIMUM_PROTECTION'
    ESSENTIAL_PROTECTION = 'ESSENTIAL_PROTECTION'


class EssentialProtection(Enum):
    ADULT = 'ADULT'
    ARMS = 'ARMS'
    CRIME = 'CRIME'
    INJURY = 'INJURY'
    PIRACY = 'PIRACY'
    DRUGS = 'DRUGS'
    HATE_SPEECH = 'HATE_SPEECH'
    MILITARY = 'MILITARY'
    OBSCENITY = 'OBSCENITY'
    TERRORISM = 'TERRORISM'
    TOBACCO = 'TOBACCO'


class OracleDataCloudBrandSafety(BaseModel):
    targetingOption: Optional[TargetingOption] = None
    essentialProtection: Optional[EssentialProtection] = None


class FraudInvalidTraffic1(Enum):
    ALLOW_ALL = 'ALLOW_ALL'
    FRAUD_INVALID_TRAFFIC_EXCLUDE_HIGH_RISK = 'FRAUD_INVALID_TRAFFIC_EXCLUDE_HIGH_RISK'
    FRAUD_INVALID_TRAFFIC_EXCLUDE_HIGH_MODERATE_RISK = (
        'FRAUD_INVALID_TRAFFIC_EXCLUDE_HIGH_MODERATE_RISK'
    )


class IasBrandSafetyLevel(Enum):
    ALLOW_ALL = 'ALLOW_ALL'
    BRAND_SAFETY_EXCLUDE_HIGH_RISK = 'BRAND_SAFETY_EXCLUDE_HIGH_RISK'
    BRAND_SAFETY_EXCLUDE_HIGH_AND_MODERATE_RISK = (
        'BRAND_SAFETY_EXCLUDE_HIGH_AND_MODERATE_RISK'
    )


class IasBrandSafety(BaseModel):
    iasBrandSafetyAdult: IasBrandSafetyLevel
    iasBrandSafetyAlcohol: IasBrandSafetyLevel
    iasBrandSafetyGambling: IasBrandSafetyLevel
    iasBrandSafetyHateSpeech: IasBrandSafetyLevel
    iasBrandSafetyIllegalDownloads: IasBrandSafetyLevel
    iasBrandSafetyIllegalDrugs: IasBrandSafetyLevel
    iasBrandSafetyOffensiveLanguage: IasBrandSafetyLevel
    iasBrandSafetyViolence: IasBrandSafetyLevel
    excludeContent: bool = Field(
        ...,
        description='Set to `true` to exclude content that Integral Ad Science is not able to rate.',
    )


class Standard(Enum):
    NONE = 'NONE'
    MRC = 'MRC'
    GROUPM = 'GROUPM'
    PUBLICIS = 'PUBLICIS'


class IasViewability(BaseModel):
    standard: Standard = Field(..., description='The viewability standard')
    viewabilityTargeting: ViewabilityTier


class DomainListMergedTargetingType(Enum):
    EXCLUDE = 'EXCLUDE'
    INCLUDE = 'INCLUDE'


class MergedDomainList(BaseModel):
    domainListMergedTargetingType: Optional[DomainListMergedTargetingType] = Field(
        None, description='The list type of the domain. Either include or exclude'
    )
    domainListMergedFile: Optional[str] = Field(
        None,
        description='The URL address of the domain list file after merging all domains into single file"',
    )


class DomainList(BaseModel):
    mergedDomainList: Optional[MergedDomainList] = None
    inheritFromAdvertiser: Optional[bool] = Field(
        None, description='Inherit domains from advertiser settings.'
    )


class TimeZonePreference(Enum):
    USER_TIMEZONE = 'USER_TIMEZONE'
    AD_SERVER_TIMEZONE = 'AD_SERVER_TIMEZONE'


class HourSlot(BaseModel):
    __root__: conint(ge=0, le=23) = Field(..., description='The hour slot.')


class DayOfWeek(Enum):
    SUNDAY = 'SUNDAY'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'


class DayPart(BaseModel):
    hourSlots: List[HourSlot]
    dayOfWeek: DayOfWeek = Field(..., description='The day of the week.')


class MobileOsTargeting(Enum):
    ANY = 'ANY'
    IOS = 'IOS'
    ANDROID = 'ANDROID'


class AppTargetingOption(Enum):
    INCLUDE_APPS = 'INCLUDE_APPS'
    EXCLUDE_APPS = 'EXCLUDE_APPS'


class MobileAppTargeting(BaseModel):
    appTargetingOption: AppTargetingOption = Field(
        ..., description='The mobile application targeting inclusion type.'
    )
    appIds: List[str] = Field(...,
                              description='The list of application identifiers.')


class LineItemOptimization(BaseModel):
    budgetOptimization: bool = Field(
        ...,
        description='Set to `true` to enable budget optimization for the line item.',
    )


class DeliveryProfile(Enum):
    FRONT_LOADED = 'FRONT_LOADED'
    EVENLY = 'EVENLY'


class CatchUpBoost(Enum):
    CATCH_UP_BOOST_2X = 'CATCH_UP_BOOST_2X'
    CATCH_UP_BOOST_3X = 'CATCH_UP_BOOST_3X'
    CATCH_UP_BOOST_4X = 'CATCH_UP_BOOST_4X'
    NONE = 'NONE'


class Pacing(BaseModel):
    deliveryProfile: DeliveryProfile = Field(
        ...,
        description='The type of line item delivery profile. FRONT_LOADED: Initially front-load 20% of the budget. Remaining delivery is spread evenly across the remaining duration of the line item. Note that catchup boosts do not apply to this delivery profile. EVENLY: Distributes the delivery evenly across the duration of the line items. Catchup boosts are enabled for this delivery profile.',
    )
    catchUpBoost: Optional[CatchUpBoost] = Field(
        None,
        description='The catch up boost value associated with the line item. Represents the percentage of additional delivery that can be targeted when the line item is under-pacing. A catchup boost only applies to the EVENLY deliver profile. CatchUpBoost_2X: 200. CatchUpBoost_3X: 300. CatchUpBoost_4X: 400.',
    )


class ProviderName(Enum):
    INTEGRAL_AD_SCIENCE = 'INTEGRAL_AD_SCIENCE'
    DOUBLE_VERIFY = 'DOUBLE_VERIFY'
    DOUBLE_CLICK_CAMPAIGN_MANAGER = 'DOUBLE_CLICK_CAMPAIGN_MANAGER'
    COM_SCORE = 'COM_SCORE'
    CPM_1 = 'CPM_1'
    CPM_2 = 'CPM_2'
    CPM_3 = 'CPM_3'


class FeeAllocation(Enum):
    ABSORB_WITH_AGENCY_FEE = 'ABSORB_WITH_AGENCY_FEE'
    PASS_TO_ADVERTISER = 'PASS_TO_ADVERTISER'


class ThirdPartyFee(BaseModel):
    providerName: ProviderName = Field(..., description='The provider name.')
    feeAmount: float = Field(
        ..., description='The fee amount associated a third-party provider.'
    )
    feeAllocation: FeeAllocation = Field(...,
                                         description='The type of fee allocation.')


class FeeName(Enum):
    IN_MARKET_LIFESTYLE = 'IN_MARKET_LIFESTYLE'
    AUTOMOTIVE = 'AUTOMOTIVE'


class AudienceFee(BaseModel):
    feeName: FeeName = Field(...,
                             description='The category of the audience fee.')
    amount: float = Field(..., description='The amount of the audience fee.')


class AmazonConsoleFee(BaseModel):
    feePercentage: float = Field(
        ..., description='The service fee expressed as a percentage.'
    )


class Bidding(BaseModel):
    baseSupplyBid: float = Field(
        ...,
        description='The base bid per thousand impressions for ad inventory. Expressed in dollars.',
    )
    maxSupplyBid: Optional[float] = Field(
        None,
        description='The maximum cost-per-thousand impressions bid for media supply. Expressed in dollars.',
    )


class LineItemDeliveryStatus(Enum):
    DELIVERING = 'DELIVERING'
    ENDED = 'ENDED'
    OUT_OF_BUDGET = 'OUT_OF_BUDGET'
    INACTIVE = 'INACTIVE'
    READY_TO_DELIVER = 'READY_TO_DELIVER'
    CREATIVES_NOT_RUNNING = 'CREATIVES_NOT_RUNNING'


class RecurrenceTimePeriod(Enum):
    UNCAPPED = 'UNCAPPED'
    DAILY = 'DAILY'
    MONTHLY = 'MONTHLY'


class BudgetCap(BaseModel):
    recurrenceTimePeriod: RecurrenceTimePeriod = Field(
        ..., description='The type of recurrence for the spending limit.'
    )
    amount: float = Field(..., description='The spending limit amount.')


class CurrencyCode(Enum):
    USD = 'USD'
    CAD = 'CAD'
    MXN = 'MXN'


class Type(Enum):
    UNCAPPED = 'UNCAPPED'
    CUSTOM = 'CUSTOM'


class TimeUnit(Enum):
    DAYS = 'DAYS'
    HOURS = 'HOURS'


class FrequencyCap(BaseModel):
    type: Type = Field(
        ...,
        description='The type of advertising frequency cap. If `UNCAPPED`, no other fields are used.',
    )
    maxImpressions: Optional[int] = Field(
        None, description='The maximum number of times an ad is displayed.'
    )
    timeUnitCount: Optional[int] = Field(
        None, description='The count of time units.')
    timeUnit: Optional[TimeUnit] = Field(None, description='The time unit.')


class Identifier(BaseModel):
    __root__: str = Field(
        ..., description='The unique identifier of the DSP resource/object.'
    )


class CreativeRotationType(Enum):
    WEIGHTED = 'WEIGHTED'
    RANDOM = 'RANDOM'


class CreativeOptions(BaseModel):
    creativeRotationType: Optional[CreativeRotationType] = Field(
        None, description='The creative rotation type.'
    )


class Creative(BaseModel):
    advertiserId: Optional[str] = Field(
        None, description='The identifier of the advertiser.'
    )
    creativeId: Optional[str] = Field(
        None, description='The identifier of the creative.'
    )
    type: Optional[str] = Field(None, description='The creative type.')
    name: Optional[str] = Field(None, description='The creative name.')
    externalId: Optional[str] = Field(
        None, description='The external identifier of the creative.'
    )
    size: Optional[str] = Field(None, description='The creative size.')
    supportedLineItemTypes: Optional[List[LineItemType]] = Field(
        None, description='Supported lineItemTypes where creatives can be associated.'
    )


class DeliveryActivationStatus(Enum):
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'


class ProductAssociation(Enum):
    FEATURED = 'FEATURED'
    NOT_FEATURED = 'NOT_FEATURED'


class Domain(Enum):
    AMAZON_US = 'AMAZON_US'
    AMAZON_CA = 'AMAZON_CA'
    AMAZON_MX = 'AMAZON_MX'
    PRIME_NOW_US = 'PRIME_NOW_US'
    PRIME_NOW_CA = 'PRIME_NOW_CA'
    WHOLE_FOODS_MARKET_US = 'WHOLE_FOODS_MARKET_US'


class ProductTrackingItem(BaseModel):
    productId: str = Field(..., description='The product identifier.')
    productAssociation: ProductAssociation = Field(
        ..., description='The product feature type.'
    )
    domain: Domain = Field(
        ..., description='The ASIN domain type. Applicable to ASIN line item type only.'
    )


class ProductTracking(BaseModel):
    productList: Optional[List[ProductTrackingItem]] = Field(
        None, description='The tracking product list.'
    )
    productFile: Optional[str] = Field(
        None, description='The URL of the product tracking file.'
    )


class PixelTracking(BaseModel):
    __root__: List[str] = Field(
        ..., description='A list of pixels associated with the campaign.'
    )


class ConversionTracking(BaseModel):
    products: Optional[ProductTracking] = None
    pixels: Optional[PixelTracking] = None


class LineItemCreativeAssociationOperation(Enum):
    CREATE = 'CREATE'
    DELETE = 'DELETE'


class LineItemCreativeAssociation(BaseModel):
    lineItemId: str = Field(..., description='The lineitem to operate on.')
    creativeId: str = Field(..., description='The creative to operate on.')
    startDate: Optional[str] = Field(
        None,
        description='The creative start date in ISO format (YYYY-MM-DD hh:mm:ss z). Timezone is UTC. For example, 2020-10-21 03:59:00 UTC.',
    )
    endDate: Optional[str] = Field(
        None,
        description='The creative end date in in ISO format (YYYY-MM-DD hh:mm:ss z). Timezone is UTC. For example, 2020-10-21 03:59:00 UTC.',
    )
    weight: Optional[int] = Field(
        None,
        description='The weight of the creative. This field will be available only if the creative rotation type is `WEIGHTED`.',
    )


class PurposeEnum(Enum):
    ENGAGEMENT = 'ENGAGEMENT'
    REMARKETING = 'REMARKETING'
    CONVERSION = 'CONVERSION'


class Event(Enum):
    MARKETING_LANDING_PAGE = 'MARKETING_LANDING_PAGE'


class Pixel(BaseModel):
    id: Optional[str] = Field(
        None, example='12345678-abcd-abcd-abcd-012345679ef')
    name: Optional[str] = Field(None, example='PIXEL_AMZ_ENGAGE')
    purpose: Optional[List[PurposeEnum]] = None
    event: Optional[Event] = Field(None, example='MARKETING_LANDING_PAGE')
    domain: Optional[str] = Field(None, example='www.amazon.com')
    description: Optional[str] = Field(
        None, example='Pixel for Amazon engagement')
    advertiserId: Optional[str] = Field(None, example=123456789)
    created: Optional[datetime] = None


class ProductCategory(BaseModel):
    id: str = Field(..., description='The category identifier.')
    name: str = Field(..., description='The category name.')
    parentId: Optional[str] = Field(
        None,
        description='The identifier of the parent category. This is blank if the category is a parent category.',
    )


class SupplySourceType(Enum):
    AMAZON_EXCLUSIVE = 'AMAZON_EXCLUSIVE'
    OPEN_EXCHANGE = 'OPEN_EXCHANGE'
    DEAL = 'DEAL'


class DealType(Enum):
    PREFERRED_DEAL = 'PREFERRED_DEAL'
    PRIVATE_AUCTION = 'PRIVATE_AUCTION'


class DealInfo(BaseModel):
    dealType: Optional[DealType] = None
    dealGroup: Optional[str] = None
    publisherName: Optional[str] = None
    dealPrice: Optional[int] = None
    startDate: Optional[datetime] = None
    endDate: Optional[datetime] = None
    exchangeName: Optional[str] = None


class DomainListMetadata(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    size: Optional[int] = Field(
        None, description='Number of URLs specified in this list'
    )
    created: Optional[datetime] = None
    updated: Optional[datetime] = None


class Category(Enum):
    COUNTRY = 'COUNTRY'
    STATE = 'STATE'
    CITY = 'CITY'
    POSTAL_CODE = 'POSTAL_CODE'
    DMA = 'DMA'


class GeoLocation(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = Field(None, description='Name of geo location.')
    category: Optional[Category] = Field(
        None, description='Category of the geo location.'
    )


class IABContentCategory(BaseModel):
    id: str = Field(..., description='The category identifier.')
    name: str = Field(..., description='The category name.')
    parentId: Optional[str] = Field(
        None,
        description='The identifier of the parent category. This is blank if the category is a parent category.',
    )


class OdcCustomPredict(BaseModel):
    id: str = Field(..., description='The segment identifier.')
    name: str = Field(..., description='The segment name.')


class DvCustomContextualSegment(BaseModel):
    id: str = Field(..., description='The segment identifier.')
    name: str = Field(..., description='The segment name.')


class AvailableKpi(BaseModel):
    kpiName: Optional[GoalKpi] = None
    autoOptimizations: Optional[List[AutoOptimization]] = Field(
        None, description='Which optimizations can be applied for this KPI'
    )


class GoalConfiguration(BaseModel):
    goalName: Optional[Goal] = None
    availableKpis: Optional[List[AvailableKpi]] = None


class AdType(Enum):
    DSP = 'DSP'
    SD = 'SD'


class AudienceFilter(BaseModel):
    field: Optional[str] = Field(
        None,
        description="Field to filter by. Valid values are 'audienceName', 'category', and 'audienceId'",
        example='audienceName',
    )
    values: Optional[List[str]] = None


class Status(Enum):
    PROCESSING = 'PROCESSING'
    ACTIVE = 'ACTIVE'
    FAILED = 'FAILED'
    DEPRECATED = 'DEPRECATED'
    DEACTIVATED = 'DEACTIVATED'


class AudienceCommonFields(BaseModel):
    audienceId: Optional[str] = Field(
        None, description='Audience segment identifier')
    audienceName: Optional[str] = Field(None, description='Audience name')
    category: Optional[str] = Field(
        None, description='Audience segment category', example='In-market'
    )
    createDate: Optional[datetime] = Field(
        None, description='Only provided for segments in private catalogs.'
    )
    updateDate: Optional[datetime] = Field(
        None, description='Only provided for segments in private catalogs.'
    )
    status: Optional[Status] = None


class Fee(BaseModel):
    amount: Optional[int] = Field(
        None,
        description="Fee amount in base currency units, multiplied by scaling factor ('scale').",
        example=500,
    )
    currency: Optional[str] = Field(
        None,
        description='Base currency, such as US Dollar, given in ISO 4217.',
        example='USD',
    )
    scale: Optional[int] = Field(
        None,
        description='Scale of the amount relative to the base currency unit. For instance, if the scale is 100000, the currency is USD, and the amount is 50000, the human-readable fee is $0.50.',
        example=1000,
    )
    feeCalculationType: Optional[str] = Field(
        None, description='How the fee is applied.', example='CPM'
    )
    impressionSupplyType: Optional[str] = Field(
        None,
        description='Which supply types this fee applies to. The fee may be different for different supply types.',
        example='WEB',
    )


class DSPAudienceFields(BaseModel):
    fees: Optional[List[Fee]] = Field(
        None,
        description='Fees that will apply to this segment. Multiple fees objects will be present corresponding to different impression supply types. Fee amount may differ depending on the impression supply type the segment is attached to.',
    )


class SDAudienceFields(BaseModel):
    pass


class SubError(BaseModel):
    errorType: str
    message: str
    fieldName: Optional[str] = None


class OrderBudgetBasic(BaseModel):
    totalBudgetAmount: Optional[float] = Field(
        None,
        description='The total budget amount. For create/update operations, budget has to be modeled as part of flights object.\n',
    )
    budgetCaps: Optional[List[BudgetCap]] = None


class OrderBudget(OrderBudgetBasic):
    flights: Optional[List[OrderFlight]] = Field(
        None,
        description='The budget, start date and end date for an order have to be modeled as flight object. An order can have multiple flights.\n',
        min_items=1,
    )


class LineItemClassification(BaseModel):
    productCategories: List[Identifier] = Field(
        ...,
        description='The array of identifiers of product categories associated with the line item.',
    )


class SupplyDealTargeting(BaseModel):
    deals: Optional[List[Identifier]] = Field(
        None, description='The list of deal supply sources to target.'
    )


class SupplySourceTargeting(BaseModel):
    supplySources: Optional[List[Identifier]] = Field(
        None, description='The list of supply sources to target.'
    )


class GeoLocationTargeting(BaseModel):
    locationTargetingBy: Optional[LocationTargetingBy] = Field(
        None,
        description='The geographic location targeting type. IPADDRESS: includes IP address only. IPADDRESS_POSTALCODE: includes both IP address and postal code.',
    )
    inclusions: Optional[List[Identifier]] = None
    exclusions: Optional[List[Identifier]] = None


class SegmentClause(BaseModel):
    segmentId: Identifier
    isNot: Optional[bool] = Field(
        None,
        description='Set to `true` to set to negative targeting. Set to `false` to set to  positive targeting. Default is false.',
    )


class AmazonViewabilityTargeting(BaseModel):
    viewabilityTier: ViewabilityTier
    includeUnmeasurableImpressions: bool = Field(
        ...,
        description="Set to `true` to include impressions where impressions can't be measured.",
    )


class DoubleVerify(BaseModel):
    brandSafety: Optional[DoubleVerifyBrandSafety] = None
    fraudInvalidTraffic: Optional[DoubleVerifyFraudInvalidTraffic] = None
    authenticBrandSafety: Optional[DoubleVerifyAuthenticBrandSafety] = None
    viewability: Optional[DoubleVerifyViewability] = None
    customContextualSegmentId: Optional[str] = Field(
        None, description='The custom segment identifier.'
    )


class OracleDataCloud(BaseModel):
    brandSafety: Optional[OracleDataCloudBrandSafety] = None
    fraudInvalidTraffic: Optional[FraudInvalidTraffic] = Field(
        None, description='The fraud invalid traffic type.'
    )
    customSegmentId: Optional[str] = Field(
        None, description='The custom segment identifier.'
    )
    contextualPredictsSegmentId: Optional[str] = Field(
        None, description='The custom segment predict identifier.'
    )


class IntegralAdScience(BaseModel):
    brandSafety: Optional[IasBrandSafety] = None
    fraudInvalidTraffic: Optional[FraudInvalidTraffic1] = Field(
        None, description='The type of fraud invalid traffic.'
    )
    viewability: Optional[IasViewability] = None


class DayPartTargeting(BaseModel):
    timeZonePreference: TimeZonePreference = Field(
        ..., description='The time zone associated with line item delivery.'
    )
    dayParts: List[DayPart] = Field(...,
                                    description='The list of parts of the day.')


class LineItemBudget(BaseModel):
    totalBudgetAmount: Optional[float] = Field(
        None, description='The total budget amount.'
    )
    budgetCaps: Optional[List[BudgetCap]] = None
    pacing: Optional[Pacing] = None


class AppliedFees(BaseModel):
    thirdPartyFees: Optional[List[ThirdPartyFee]] = Field(
        None, description='The list of third party fees associated with the line item.'
    )
    audienceFees: Optional[List[AudienceFee]] = Field(
        None, description='The list of audience fees associated with the line item.'
    )
    amazonDspConsoleFee: Optional[AmazonConsoleFee] = None


class Creatives(BaseModel):
    totalResults: Optional[int] = Field(
        None,
        description='Total number of results which satisfy the filtering criteria. This will help to support pagination.',
    )
    response: Optional[List[Creative]] = Field(
        None, max_items=100, min_items=1)


class LineItemCreativeAssociationsRequest(BaseModel):
    advertiserId: str = Field(..., description='The advertiser identifier.')
    operation: LineItemCreativeAssociationOperation
    associations: List[LineItemCreativeAssociation] = Field(
        ...,
        description='A list of the associations to operate on. This object requires only lineItemId and creativeId and other fields are not required.',
        max_items=1,
        min_items=1,
    )


class LineItemCreativeAssociations(BaseModel):
    totalResults: Optional[int] = Field(
        None,
        description='Total number of results which satisfy the filtering criteria. This will help to support pagination.',
    )
    response: Optional[List[LineItemCreativeAssociation]] = Field(
        None, max_items=20, min_items=1
    )


class SupplySource(BaseModel):
    id: Optional[str] = Field(None, description='ID of the supply source item')
    name: Optional[str] = Field(
        None, description='User friendly name of the supply source item'
    )
    supplySourceType: Optional[SupplySourceType] = Field(
        None, description='Type of this item'
    )
    dealInfo: Optional[DealInfo] = None


class OdcCustomPredicts(BaseModel):
    nextToken: Optional[str] = None
    customPredicts: Optional[List[OdcCustomPredict]] = None


class DvCustomContextualSegments(BaseModel):
    nextToken: Optional[str] = None
    customContextualSegments: Optional[List[DvCustomContextualSegment]] = None


class ListAudiencesRequestBody(BaseModel):
    adType: Optional[AdType] = Field(
        None, description='The type of ad this segment will be used with.'
    )
    filters: Optional[List[AudienceFilter]] = Field(
        None, description='Resulting segments will match all specified filters'
    )


class Audience(AudienceCommonFields):
    pass


class Error(BaseModel):
    requestId: Optional[str] = Field(
        None, description='Request Id that uniquely identifies your request.'
    )
    message: Optional[str] = Field(
        None, description='A human-readable description of the response.'
    )
    errors: Optional[List[SubError]] = None


class OrderBasic(BaseModel):
    orderId: Optional[str] = Field(None, description='The order identifier.')
    advertiserId: Optional[str] = Field(
        None, description='The advertiser identifier.')
    name: Optional[str] = Field(None, description='The order name.')
    externalId: Optional[str] = Field(
        None, description='The order external identifier.'
    )
    comments: Optional[str] = Field(None, description='The order comments.')
    startDateTime: Optional[str] = Field(
        None,
        description='The order start date in ISO format (YYYY-MM-DDThh:mm:ssTZD). Timezone is UTC. For example, 2020-12-16T19:20:30+01:00 UTC',
    )
    endDateTime: Optional[str] = Field(
        None,
        description='The order end date in ISO format (YYYY-MM-DDThh:mm:ssTZD). Timezone is UTC. For example, 2020-12-16T19:20:30+01:00 UTC',
    )
    budget: Optional[OrderBudget] = None
    agencyFee: Optional[AgencyFee] = None
    currencyCode: Optional[CurrencyCode] = None
    deliveryActivationStatus: Optional[DeliveryActivationStatus] = None
    deliveryStatus: Optional[OrderDeliveryStatus] = None
    frequencyCap: Optional[FrequencyCap] = None
    optimization: Optional[OrderOptimization] = None


class Order(BaseModel):
    orderId: Optional[str] = Field(
        None,
        description='The order identifier. It will be used to perform update operation. Immutable field.',
    )
    advertiserId: Optional[str] = Field(
        None, description='The advertiser identifier. Immutable field.'
    )
    name: str = Field(..., description='The order name.')
    externalId: Optional[str] = Field(
        None, description='The order external identifier.'
    )
    comments: Optional[str] = Field(None, description='The order comments.')
    startDateTime: Optional[str] = Field(
        None,
        description='The order start date in ISO format (YYYY-MM-DDThh:mm:ssTZD). Timezone is UTC. For example, 2020-12-16T19:20:30+01:00 UTC. The start date has to be modeled as a part of flights object.\n',
    )
    endDateTime: Optional[str] = Field(
        None,
        description='The order end date in ISO format (YYYY-MM-DDThh:mm:ssTZD). Timezone is UTC. For example, 2020-12-16T19:20:30+01:00 UTC. The end date has to be modeled as a part of flights object.\n',
    )
    budget: OrderBudget
    currencyCode: Optional[CurrencyCode] = None
    agencyFee: Optional[AgencyFee] = Field(
        None, description='It is immutable if the order has one or more lineItems.'
    )
    frequencyCap: FrequencyCap
    optimization: OrderOptimization
    deliveryActivationStatus: Optional[DeliveryActivationStatus] = None
    deliveryStatus: Optional[OrderDeliveryStatus] = None
    creationDate: Optional[str] = Field(
        None,
        description='The order creation date in ISO format (YYYY-MM-DDThh:mm:ssTZD). Timezone is UTC. For example, 2020-12-16T19:20:30+01:00.',
    )
    lastUpdatedDate: Optional[str] = Field(
        None,
        description='The order last update date in ISO format (YYYY-MM-DDThh:mm:ssTZD). Timezone is UTC. For example, 2020-12-16T19:20:30+01:00.',
    )


class OrderResponse(BaseModel):
    orderId: Optional[str] = Field(None, description='The order Identifier.')
    errorDetails: Optional[Error] = None


class LineItemBasic(BaseModel):
    lineItemId: Optional[str] = Field(
        None, description='The line item identifier.')
    lineItemType: Optional[LineItemType] = None
    name: Optional[str] = Field(None, description='The line item name.')
    externalId: Optional[str] = Field(
        None, description='The line item external identifier.'
    )
    comments: Optional[str] = Field(
        None, description='The line item comments.')
    orderId: Optional[str] = Field(
        None, description='The order to which the line item is associated.'
    )
    startDateTime: Optional[str] = Field(
        None,
        description='The line item start date in ISO date format (YYYY-MM-DDThh:mm:ssTZD). Timezone is UTC. For example, 2020-07-16T19:20:30+01:00',
    )
    endDateTime: Optional[str] = Field(
        None,
        description='The line item end date in ISO format (YYYY-MM-DDThh:mm:ssTZD). Timezone is UTC. For example,2020-07-16T19:20:30+01:00',
    )
    deliveryActivationStatus: Optional[DeliveryActivationStatus] = None
    deliveryStatus: Optional[LineItemDeliveryStatus] = None
    currencyCode: Optional[CurrencyCode] = None
    bidding: Optional[Bidding] = None
    budget: Optional[LineItemBudget] = None
    frequencyCap: Optional[FrequencyCap] = None
    optimization: Optional[LineItemOptimization] = None


class LineItemResponse(BaseModel):
    lineItemId: Optional[str] = Field(
        None, description='The Line item identifier.')
    errorDetails: Optional[Error] = None


class SupplyTargeting(BaseModel):
    supplySourceTargeting: Optional[SupplySourceTargeting] = None
    supplyDealTargeting: Optional[SupplyDealTargeting] = None


class SegmentGroup(BaseModel):
    segments: List[SegmentClause] = Field(
        ..., description='The list of segment clauses.'
    )
    intraOperator: IntraOperator = Field(
        ..., description='The intra operator used between two segment groups.'
    )
    interOperator: InterOperator = Field(
        ...,
        description='The inter operator used among segments within the same segment group.',
    )


class ThirdPartyPreBidTargeting(BaseModel):
    doubleVerify: Optional[DoubleVerify] = None
    oracleDataCloud: Optional[OracleDataCloud] = None
    integralAdScience: Optional[IntegralAdScience] = None


class LineItemCreativeAssociationsResponse(BaseModel):
    success: Optional[LineItemCreativeAssociation] = None
    errorDetails: Optional[Error] = None


class ListAudiencesResponse(BaseModel):
    nextToken: Optional[str] = None
    audiences: Optional[List[Audience]] = Field(
        None,
        description='Array of segments matching given filters sorted by match score, best first.',
    )


class Orders(BaseModel):
    totalResults: Optional[int] = Field(
        None,
        description='Total number of results which satisfy the filtering criteria. This will help to support pagination.',
    )
    response: Optional[List[OrderBasic]] = Field(
        None, max_items=100, min_items=1)


class LineItems(BaseModel):
    totalResults: Optional[int] = Field(
        None,
        description='Total number of results which satisfy the filtering criteria. This will help to support pagination.',
    )
    response: Optional[List[LineItemBasic]] = Field(
        None, max_items=100, min_items=1)


class SegmentTargeting(BaseModel):
    segmentGroups: Optional[List[SegmentGroup]] = Field(
        None, description='The list of segment groups.'
    )


class AmazonMobileDisplayTargeting(BaseModel):
    userLocationTargeting: Optional[UserLocationTargeting] = None
    amazonViewabilityTargeting: Optional[AmazonViewabilityTargeting] = None
    thirdPartyPreBidTargeting: Optional[ThirdPartyPreBidTargeting] = None
    supplyTargeting: Optional[SupplyTargeting] = None
    geoLocationTargeting: Optional[GeoLocationTargeting] = None
    segmentTargeting: Optional[SegmentTargeting] = None
    dayPartTargeting: Optional[DayPartTargeting] = None
    mobileOsTargeting: Optional[MobileOsTargeting] = None
    contextualTargeting: Optional[bool] = Field(
        None,
        description='Set to `true` to enable contextual targeting. Contextual targeting targets the detail page of products that are frequently viewed or purchased with the products in your ad. Note that this feature applies to Dynamic eCommerce ads only.',
    )


class StandardDisplayTargeting(BaseModel):
    userLocationTargeting: Optional[UserLocationTargeting] = None
    amazonViewabilityTargeting: Optional[AmazonViewabilityTargeting] = None
    thirdPartyPreBidTargeting: Optional[ThirdPartyPreBidTargeting] = None
    supplyTargeting: Optional[SupplyTargeting] = None
    geoLocationTargeting: Optional[GeoLocationTargeting] = None
    segmentTargeting: Optional[SegmentTargeting] = None
    dayPartTargeting: Optional[DayPartTargeting] = None
    domainListTargeting: Optional[DomainList] = None
    deviceTypeTargeting: Optional[DeviceTypeTargeting] = Field(
        None,
        description='The targeted device type for standard display line item type. It is required input for `STANDARD_DISPLAY` line item type.',
    )
    mobileOsTargeting: Optional[MobileOsTargeting] = None
    siteLanguageTargeting: Optional[SiteLanguageTargeting] = Field(
        None, description='The site language targeting type. For example, `EN`, `ES`.'
    )
    contentTargeting: Optional[List[Identifier]] = Field(
        None,
        description='The IAB content category type. IAB content categories enable accounts to target websites according to their subject matter by scanning their content. This helps deliver ads to relevant sites while ensuring that the ads are not displayed near undesirable content.',
    )
    contextualTargeting: Optional[bool] = Field(
        None,
        description='Set to `true` to enable contextual targeting. Contextual targeting targets the detail page of products that are frequently viewed or purchased with the products in your ad. Note that this feature applies to Dynamic eCommerce ads only.',
    )


class AapMobileAppTargeting(BaseModel):
    userLocationTargeting: Optional[UserLocationTargeting] = None
    amazonViewabilityTargeting: Optional[AmazonViewabilityTargeting] = None
    thirdPartyPreBidTargeting: Optional[ThirdPartyPreBidTargeting] = None
    supplyTargeting: Optional[SupplyTargeting] = None
    geoLocationTargeting: Optional[GeoLocationTargeting] = None
    segmentTargeting: Optional[SegmentTargeting] = None
    dayPartTargeting: Optional[DayPartTargeting] = None
    mobileAppTargeting: Optional[MobileAppTargeting] = None
    deviceTypeTargeting: Optional[List[DeviceTypeTargetingEnum]] = Field(
        None,
        description='The targeted mobile application device type. Note that this is applicable only for the `AAP_MOBILE APP` type of line item. It is required input for `AAP_MOBILE APP` line item type.',
    )
    deviceOrientationTargeting: Optional[DeviceOrientationTargeting] = Field(
        None, description='The mobile device orientation targeting type.'
    )


class LineItemTargeting(BaseModel):
    standardDisplayTargeting: Optional[StandardDisplayTargeting] = None
    aapMobileAppTargeting: Optional[AapMobileAppTargeting] = None
    amazonMobileDisplayTargeting: Optional[AmazonMobileDisplayTargeting] = None


class LineItem(BaseModel):
    lineItemId: Optional[str] = Field(
        None,
        description='The line item identifier. This is required when we perform update operations. Immutable field.',
    )
    lineItemType: LineItemType
    name: str = Field(..., description='The line item name.')
    orderId: str = Field(
        ...,
        description='The order to which the line item is associated. Immutable field.',
    )
    externalId: Optional[str] = Field(
        None, description='The external identifier of the line item.'
    )
    startDateTime: str = Field(
        ...,
        description='The line item start date in ISO date format (YYYY-MM-DDThh:mm:ssTZD). Timezone is UTC. For example, 2020-07-16T19:20:30+01:00.',
    )
    endDateTime: str = Field(
        ...,
        description='The line item end date in ISO format (YYYY-MM-DDThh:mm:ssTZD). Timezone is UTC. For example, 2020-07-16T19:20:30+01:00',
    )
    comments: Optional[str] = Field(
        None, description='The line item comments.')
    deliveryActivationStatus: Optional[DeliveryActivationStatus] = None
    deliveryStatus: Optional[LineItemDeliveryStatus] = None
    lineItemClassification: LineItemClassification
    frequencyCap: FrequencyCap
    targeting: Optional[LineItemTargeting] = None
    budget: Optional[LineItemBudget] = None
    currencyCode: Optional[CurrencyCode] = None
    appliedFees: Optional[AppliedFees] = None
    bidding: Bidding
    optimization: LineItemOptimization
    creativeOptions: Optional[CreativeOptions] = None
    creationDate: Optional[str] = Field(
        None, description='The line item creation date.'
    )
    lastUpdateDate: Optional[str] = Field(
        None, description='The line item last update date.'
    )
